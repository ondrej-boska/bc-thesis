\chapter{Developer Documentation}

\section{Data generators}

\xxx{general}

\subsection{Randomly distributed data}

\subsection{Commute data}

\section{Optimization algorithms}

All the algorithms are written in the Julia programming language. Each algorithm's source code is stored in a separate file. Other files include parsing the input data, common functions for all evolutionary algorithms (like selection or elitism), the fitness function, the runner script, configuration variables, and utility functions that did not fit elsewhere. Each of the following sections corresponds to one source file. Every function is described by a \textit{docstring} and code comments where needed, so look directly at the source files for a detailed description.

\subsection{Input data parsing}

Input data parsing is done in the \textit{input\_parser.jl} file. The data is parsed by the \texttt{load\_input} function, which takes the path to the input data generated by one of the generators. Nested in this function are auxiliary functions for:
\begin{itemize}
    \setlength\itemsep{0pt}
    \item parsing the distance and duration \textit{CSV} files using the \texttt{CSV} and \textit{DataFrames} packages. The files are first loaded into a DataFrame. The coordinates are then extracted from the header into an array, and an integer identifier is assigned instead. All the algorithms work with that identifier instead of the coordinate tuple. The distances and durations are then stored in a \texttt{Float64} two-dimensional array and returned with the coordinate to id mapping.
    \item parsing the GeoJSON file using the \texttt{GeoJSON} package. All the group requests are filtered and stored in a custom \texttt{Group} struct, and the Depot is stored in a custom \texttt{Depot} struct holding the available bus types, also stored in a custom \texttt{BusType} struct.
\end{itemize}

The function then returns the parsed data in the form of a \texttt{InputData} struct, which holds a mapping between the group's ids and their features (in a dictionary if the ids in the input GeoJSON were not continuous), the depot, the distances and durations matrices and the coordinates to their id mapping.

\subsection{Fitness function}

The fitness function calculation is stored in the \textit{fitness.jl} file. The fitness is evaluated using the \texttt{evaluate\_fitness} function, which takes a valid solution and an input data instance. The solution must be stored as a \texttt{Vector\{Vector\{Int\}\}}, where each vector is one route consisting of the pick-ups and drop-offs. The function separately calculates the bus costs (fixed cost per bus and operating cost per kilometer) and the delay penalties. These two values are then summed and returned. A \texttt{multi\_objective} parameter can be used to return these values separately in an array.

\subsection{Genetic algorithms}

Functions common for all the genetic algorithms are stored in the \textit{evolution\_base.jl} file. Implemented functions include the tournament selection, minimizing roulette wheel selection (by using the inverse of the fitness function), the method for creating an initial population from a \textit{create individual} function, methods for applying crossover and mutation on the whole population based on the given probability, and the method for applying elitism. The \texttt{run\_genetic\_algorithm} function then implements the main loop of the genetic algorithm using these functions. This function also logs the algorithm's progress. Its frequency can be adjusted by the \texttt{print\_freq} parameter. When the \texttt{verbose} parameter is set to \texttt{true}, the progress is also logged to the standard output. The \texttt{map\_fun} parameter can be used to replace the classic \texttt{map} function with the \texttt{parallel\_map} from \textit{utils.jl} to calculate the fitnesses of the population in parallel. 

Each of the 3 implemented encodings for the genetic algorithm is implemented in its separate file. In all implementations, we first define the function for creating the initial individuals. The \texttt{cross} function then implements the crossover, and the \texttt{mutation} function implements the mutation. These functions are named the same for all encodings and when running the GA, the correct ones are chosen by Julia's multiple dispatch. Every encoding also implements a \texttt{individual\_to\_solution} method to convert the individual to an instance of the solution, for which the fitness can be calculated.

\subsubsection{Individual as stops}

The individual is stored in a \texttt{Vector\{Vector\{Int\}\}}, where each of the vectors is one route.

When converting an individual to a solution, we need a data structure that returns all the groups departing from a given place. We precompute this before the GA with the \texttt{get\_departure\_place\_group\_map} function and pass it to the fitness function as a parameter.

The submutations are implemented as nested functions within the \texttt{mutation} function. When the operator is called, one of these submutations is chosen using the \texttt{sample} function from the \texttt{StatsBase} package.

\subsubsection{Individual as separate clustering and routing}

For the \textit{EVO-CR} encoding, the individual is stored in a \texttt{EvoCRIndividual} struct. The struct includes a \texttt{Vector\{Int\}} for mapping between groups and buses (routes) and a \texttt{Vector\{Int\}} for the pick up/drop off order (its length is twice the number of groups, values of the array are group's ids, each id is present exactly twice).

\subsubsection{Individual as clustering with heuristic routing}

The individual is encoded in a single \texttt{Vector\{Int\}} defining the mapping between groups and used buses.

The greedy heuristic was implemented very similarly to the implementation in \cite{Baugh1998INTRACTABILITYOT}. While the original approach worked with \textit{heuristic depth} fixed to $4$, we define it as a parameter. We precompute the time windows for each group to use when calculating the cost beforehand and store it in two separate arrays (one for the time window beginnings, one for endings). These arrays are created together with a translation array from nodes to coordinates in the \texttt{prepare\_data\_structures} function. Precomputing these values has a significant effect on the algorithm's performance.

\subsection{Ant colony optimization}

The \textit{ACO} implementation is stored in the \textit{aco.jl} file. The file includes a \texttt{ant\_colony\_optimization} function with the main loop, \texttt{initialize\_pheromone} and \texttt{update\_pheromone} functions for working with the pheromone matrix, the \texttt{attractiveness} function and the \texttt{construct\_solution} function for creating new solutions based on the pheromones. The generated solutions are stored as \texttt{Vector\{Vector\{Int\}\}} and are then directly passed to the fitness function.

The \texttt{attractiveness} function imports the greedy heuristic from \textit{EVO-H} and namely uses the \texttt{move\_cost} function for calculating the weighted sum between travel time and time violations.

\subsection{Configuration}

The configuration variables are stored in the \texttt{config.jl} file. Each variable is described in its comment. All the variables are global variables, which usually is not the best practice; however, for us, it allows simple variable overriding by the command line in the runner script.

\subsection{Runner}

In the \textit{runner.jl} file, a runner function is implemented for each optimization algorithm. Each function implements a \texttt{run\_once} function, which prepares necessary data structures (if needed), sets the random seed, and runs the optimization algorithm once. The runner functions run this function in parallel (using \texttt{@threads}). After all the runs finish, the best individual and details about the run (configuration, average run time, best fitness) are stored in separate files using functions from \textit{utils.jl}.

The configuration variable overriding is handled in \texttt{update\_config\_from\_args} function, which uses Julia's meta-programming to load key-value pairs from the command line and executes \texttt{key = value} for each of them. For string variables, quotation marks are added before and after the value.

Two \textit{main} functions are implemented; one is used when running the runner from the command line, and the other when running it in interactive mode (for example, in VS Code). Having the \textit{interactive main} separate allowed for easier experimenting during development and algorithm fine-tuning (using interactive mode reduced the compile time needed during the development because only changed functions get recompiled).

\section{Results parser}